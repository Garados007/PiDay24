# PiDay24

My entry for Pi Day 2024. This project is heavily inspired by a video by Matt Parker.

[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/LIg-6glbLkU/0.jpg)](https://www.youtube.com/watch?v=LIg-6glbLkU)

## My Pi

After calculating the first 2000 digits after the decimal point, letting it run for 14 minutes, and removing everything after the first wrong digit, I get:

```
3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706
7982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381
9644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412
7372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160
9433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949
1298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051
3200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892
3542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318
5950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473
0359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019
8938095257201065485863278865936153381827968230301952035301852968995773622599413891249721775283479131
5155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240
1285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949
1293313677028989152104752162056966024058038150193511253382430035587640247496473263914199272604269922
7967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029
5532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380
0081647060016145249192173217214772350141441973568548161361157352552133475741849468438523323907394143
3345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843
8382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118
6306744278622039194945047123713786960956364371917287467764657573962413890865832645995813390478027
```

The result is 1995 correct digits after the decimal point.

## Some comments

- The approach is not optimized and relatively slow.
- I have to copy the structures and waves several times. This is partly a limitation of the language and partly because I didn't want to spend the time to make it faster.
- I used a decimal representation of all digits in memory, with each byte representing two digits. This allowed me to debug the code easily.
- I use custom methods to add, multiply, and divide the numbers. There is no big number library and these methods are not optimized.
- It's poorly parallized (only 7 workers). Mainly because it is difficult to move structs between threads.
- The code can calculate more digits, but it needs to be optimized to get the results in a reasonable time.

What to do better in the next iteration:

- Use binary representation of data (I have to think about binary to decimal encoding with really big numbers)
- Eliminate as many wave or structure copies as possible
- Write some tests to do less manual debugging
- Split number into chunks and compute parts in parallel (see video)

